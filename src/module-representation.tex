\section{Modulo di rappresentazione}

In questa sezione viene approfondita la struttura e il contenuto del modulo di
rappresentazione presente all'interno della libreria CLAST. In particolare,
questa sezione discute le scelte compiute e il metodo utilizzato per la
definizione delle diverse classi che potranno verranno poi utilizzate dal
modulo di parsing in fase di generazione dell'AST associato al programma in
analisi.

La struttura del modulo di rappresentazione ricalca molto da vicino il
processo di valutazione del codice sorgente di un programma Common Lisp.
Questo allo scopo di ottenere delle strutture che consentano di ottenere una
rappresentazione molto vicina a quella utilizzata internamente da un reale
sistema Common Lisp, ossia la più ricca possibile. Tutto questo mentendo
sempre il riferimento al codice sorgente vero e proprio, in maniera tale da
ottenere sia informazioni rispetto alla semantica del programma a livello
macchina, sia informazioni rispetto alla semantica desiderata dall’autore del
programma.

\subsection{Processo di valutazione}

Come affermato nel precedente paragrafo, le componenti facenti parte del
modulo di rappresentazione sono particolarmente legate al processo di
valutazione utilizzato dal linguaggio. Per questa ragione, allo scopo di
fornire al lettore una migliore comprensione degli elementi che verranno
presentati nel dettaglio in seguito, in questa sottosezione viene presentato
un breve sunto del processo di valutazione e delle strutture fondamentali di
un programma scritto utilizzando il linguaggio di programmazione Common
Lisp.\\

La struttura fondamentale alla base del processo di valutazione di un
programma Lisp è la form. Una form viene infatti definita formalmente dallo
standard ANSI Common Lisp come “an object meant to be evaluated”.

Dal punto di vista pratico una form può essere rappresentata sia da un atomo
che da una lista.

Il caso in cui una form è rappresentata da un atomo è il caso più semplice
all’interno del processo di valutazione. Una volta identificato un atomo, il
sistema di valutazione deve semplicemente verificare se questo rappresenta un
oggetto auto-valutante, self-evaluating object, o un simbolo. Nel caso di un
self-evaluating object il sistema si limita a produrre come risultato
l’oggetto stesso, come il nome stesso di questa struttura suggerisce. Esempi
di self-evaluating objects sono rappresentati da numeri, sia interi che
complessi, stringhe, pathnames e array.

\begin{lstlisting}

3                        ; 3
#c(2/3 5/8)              ; #C(2/3 5/8)
#p"S:[BILL]OTHELLO.TXT"  ; #P"S:[BILL]OTHELLO.TXT"
#(a b c)                 ; #(A B C)
"fred smith"             ; "fred smith"

\end{lstlisting}

Nel caso in cui un atomo non sia un self-evaluating object, il sistema Lisp lo
identifica come simbolo. A sua volta, un simbolo può essere o una symbol
macro, una form utilizzata in sostituzione di un’altra form, o una variabile.
La prima operazione che un sistema Lisp aderente allo standard compie in
questo caso è una verifica rispetto alla presenza o meno di una definizione di
macro all’interno dell’environment lessicale in uso al momento della
valutazione. Se una definizione è effettivamente presente allora viene
applicata al funzione associata a questa al fine di produrre una form che
verrà valutata al posto del simbolo stesso. Se non dovesse essere presente una
definizione di macro all’interno dell’ambiente, il sistema Lisp assume che il
il simbolo rappresenti una variabile. Il valore della variabile associata al
simbolo viene quindi ricercato e utilizzato per ritornato come output del
processo di valutazione.\\

ESEMPIO DI SIMBOLO

Come affermato, nel caso il simbolo non sia stato identificato come symbol-
macro, il sistema assume che questo rappresenti una variabile, nel caso in cui
questo non lo sia, o più generalmente in cui non sia stato associato alcun
valore alla variabile referenziata dal simbolo, il sistema si limita a
segnalare un errore di tipo UNBOUND-VARIABLE. Sia il modulo di
rappresentazione che il modulo di parsing, seguono questa convenzione. Questo
porta ad ottenere una rappresentazione corretta del comportamento di un
programma che, a runtime, manifesterà un comportamento scorretto e un
fallimento. L’utilizzo di questa convenzione porta ad ottenere un
rappresentazione statica che presenta informazioni sufficienti a consentire
l’individuazione di comportamenti potenzialmente scorretti; esattamente ciò
che risulta più interessante per gli strumenti di source code analysis per i
quali CLAST si pone come infrastruttura abilitante.\\

Infine, nel caso in cui una form sia costituita da una lista, questa prende il
nome di compound form, e il processo di valutazione prosegue in modo più
approfondito. Ciascuna compound form viene scomposta in due componenti: un
operatore, ossia il simbolo di testa della lista, e una lista di parametri,
rappresentata da una nuova lista contenente tutti gli elementi della lista
originale ad eccezione dell’operatore. La valutazione passa quindi all’analisi
del simbolo operatore, ricercando eventuali associazioni a questo all’interno
dell’attuale environment lessicale. In base a questa ricerca la compound form
viene classificata come all’interno delle seguenti 4 categorie: special form,
macro form, function form e lambda form.

\begin{lstlisting}
(car '(+ 1 2)) => +     ; CAR is a symbol
(cdr '(+ 1 2)) => (1 2) ; CDR is a list
\end{lstlisting}

Nel caso in cui l’operatore venga identificato come il nome di una funzione,
questa viene invocata utilizzando come input la lista di parametri
identificata al passo precedente. Nel caso in cui l’operatore venga
identificato come nome di una macro, la valutazione prosegue dando inizio al
processo di valutazione delle macro illustrato nel corso del capitolo
precedente, sezione <>. Nel caso in cui l’environment in cui viene eseguita la
ricerca contenga alcuna definizione per il simbolo operatore, la compound form
viene identificata come lambda form, l’operatore viene quindi utilizzato come
una funzione e la valutazione avviene in maniera analoga a questo riportato
nel caso di una function form. Il caso più interessante dal caso in cui, a
partire dall’analisi dell’operatore, una compound form venga identificata come
una special form.\\

Il maggior interesse per compound forms di tipo special form è legato al fatto
che form di questo tipo possono utilizzare o una sintassi speciale, o regole
di valutazione speciali, o entrambi, altre ad essere in grado potenzialmente
di compiere modifiche dell’environment all’interno del quale vengono valutate
e del flusso di controllo. La valutazione di form di questo tipo può produrre
nuovi environment lessicali o dinamici all’interno dei quali verrà verranno
valutate le eventuali form innestate. Ad esempio, una compound form che
utilizza l’operatore LET, dichiara un nuovo environment lessicale, identico a
quello di invocazione, all’interno del quale vengono aggiunti dei nuovi
bindings rispetto a nomi di variabile. Questo significa che form di tipo
special form avranno un impatto particolarmente significativo sul
funzionamento del modulo di parsing, in quanto, ad esempio, avendo la
possibilità di utilizzare una sintassi speciale, ciascuna di queste
potenzialmente rappresenterà una nuova regola della grammatica target del
parser.\\

Questo conclude il breve riassunto del processo di valutazione di un programma
Common Lisp e delle strutture fondamentali che caratterizzano questo processo.
Nel prossima sezione verrano quindi approfonditi meccanismi che la libreria
CLAST utilizza per la rappresentazione di queste strutture al fine di
facilitare i compiti di analisi del codice sorgente di un programma.

\subsection{Strutture di rappresentazione}

Dopo aver brevemente presentato il processo di valutazione utilizzato da un
sistema Common Lisp e le strutture fondamentali utilizzate da questo processo,
questa sezione presenta i meccanismi che vengono forniti dalla libreria CLAST
allo scopo di rappresentare un programma.\\

La rappresentazione fornita dalla libreria è organizzata all’interno di un
grande insieme di classi, organizzate all’interno di una gerarchia sfruttando
il supporto all’ereditarietà offerto dal linguaggio e in particolare
all’ereditarietà multipla. In particolare, il supporto dell’ereditarietà
multipla viene sfruttato allo scopo di definire un insieme di classi in grado
di agire da mixins, la cui semantica verrà presentata in seguito.\\

Un mixin o trait viene tipicamente definito come una classe che definisce un
insieme i metodi o attributi allo scopo di facilitare il riuso di questi
all’interno di altre classi, senza però dover forzare la definizione una
relazione di ereditarietà diretta tra la classe mixin e la classe che opera il
riuso. Lo scopo di soluzioni di questo tipo, implementate da linguaggio di
programmazione diversi con modalità e nomi diversi, è quindi fondamentalmente
quello di facilitare il riuso di codice evitando allo stesso tempo i problemi
legati alle ambiguità che possono essere causate dall’impiego
dell’ereditarietà multipla.\\

A differenza di quanto avviene nel contesto di altri linguaggio di
programmazione, come ad esempio Scala e Swift, in Common Lisp un mixin viene
definito attraverso una semplice definizione di classe in maniera del tutto
analoga a quanto avverrebbe per la definizione di una classe tradizionale.\\

La classe fondamentale al vertice della gerarchia delle strutture esposte da
CLAST è la classe CLAST-ELEMENT. Questa classe ha il semplice scopo di
raccogliere le diverse strutture offerte dalla libreria all'interno di un
unico tipo, in maniera tale da facilitare l’ispezione e l’analisi di oggetti
prodotto dalla libreria. Per questa ragione non dichiara alcun attributo ed
alcun metodo viene specializzato rispetto a questa.\\

La prima classe concreta all’interno della gerarchia è la classe FORM. Lo
scopo di questa classe è quello di rappresentare i dettagli fondamentali di
ciascun elemento presente all’interno di un programma Common Lisp e in
particolare, fungere da nodo, ossia unità fondamentale, della rappresentazione
mediante AST fornita dalla libreria. Questa classe espone quindi tre attributi
fondamentali.\\

\begin{itemize}

\item Un attributo SOURCE, il quale riporta il codice sorgente associato al
nodo, form, in analisi, il quale facilita allo scopo di facilitare il compito
di un analizzatore che lavora a partire dalla libreria.

\item Un attributo TOP,  il quale rappresenta form all’interno della quale, la
form è innestata. Questo attributo risulta di fondamentale importanza per la
libreria in quanto consente di rappresentare un programma all’interno di una
struttura ad albero, un AST, come anticipato all’interno dei capitoli
precendenti. Questo consente di ottenere una rappresentazione universalmente
nota e per la quale le operazioni di traversal risultano particolarmente
semplici.

\item Un attributo TYPE, il quale riporta il tipo, dichiarato o potenzialmente
inferito del nodo, form, in analisi. Questo allo scopo di facilitare il lavoro
di strumenti come type checkers, che cerchino di aggiungere una tipizzazione
statica ad un linguaggio di programmazione dinamico come il Common Lisp.\\

\end{itemize}

Alla base della libreria vengono quindi definite altre due classi che, come
anticipato in precedenza, hanno lo scopo di agire da mixin. La prima di queste
classi è chiamata IMPLICIT-PROGN, la seconda è chiamata EXPANSION-COMPONENT.\\

Lo scopo della classe IMPLICIT-PROGN è quello di raccogliere gli attributi ed
i metodi necessari all’analisi di form che contengono una implicita form di
tipo PROGN. Il costrutto PROGN è il costrutto fondamentale alla definizione di
codice imperativo in Common Lisp, valuta l’insieme di form fornite in input in
sequenza e ritorna il risultato dell’ultima di queste, scartando il risultato
di tutte le precedenti. Essendo l’utilizzo di questo costrutto presente in
modo implicito alla base del funzionamento di diversi altri costrutti, come ad
esempio DEFUN e DEFMACRO, si è scelto di rendere questo fornire isolare le
responsabilità e le strutture fondamentali al parsing e all’analisi di form di
questo tipo all’interno di questo mixin, allo scopo di facilitare il riuso
all’interno delle funzioni e delle strutture dedicate al parsing dei diversi
costrutti che compiono un IMPLICIT-PROGN. I due slot fondamentali esposti da
questa classe sono i seguenti.\\

\begin{itemize}

\item IPROGN-FORMS è un attributo che tiene traccia delle form innestate
all’interno di questa e che verranno implicitamente eseguite all’interno di
una form di tipo PROGN.

\item BODY-ENV è invece un attributo che riporta un oggetto di tipo
environment, il quale rappresenta l’environment all’interno del quale verrà
eseguita la valutazione delle form memorizzate dall’attributo IPROGN-FORMS
appena riportato. È importante notare che nel caso di molte special forms,
questo attributo risulta di fondamentale importanza agli scopi di uno
strumento di analisi, in quanto consente di osservare il reale ambiente di
valutazione.

\end{itemize}

SE METTI QUESTA PARTE DOPO LA PARTE RELATIVA AL PARSING QUA PUOI SPIEGARE IL
FATTO CHE BODY-ENV, NEL CASO DI ISTRUZIONI COME LET, È MOLTO DIVERSO
DALL’ENVIRONMENT RITORNATO, IN QUANTO ISTRUZIONI COME LET SONO IN GRADO DI
PRODURRE UN NUOVO ENVIRONMENT, LESSICALE O DINAMICO, AGGIUNGENDO NUOVE
INFORMAZIONI A QUESTO, ALL’INTERNO DEL QUALE VERRANO VALUTATE LE IMPROGN-
FORMS. SE INVECE VIENE MESSA PRIMA È NECESSARIO SPIEGARE NELLA SEZIONE
RELATIVA AL PARSING CHE IN ALCUNI CASI SI HA QUESTA DIFFERENZA.\\

La classe EXPANSION-COMPONENT è invece responsabile per la definizione delle
strutture e dei metodi che consentono il parsing di form soggette a processo
di valutazione tipico di una macro. Questa classe in particolare espone un
altro attributo fondamentale ad uno strumento per l’analisi di un programma
Lisp, ossia la risultato dell’espansione della form rappresentata dal nodo.\\

Le tre classi appena riportate rappresentano il substrato fondamentale della
rappresentazione offerta dalla libreria CLAST. Il livello di dettaglio offerto
dalla libreria è però molto maggiore rispetto a quello possibile utilizzando
solamente queste tre classi. La libreria infatti dichiara più di cento classi
che vengono utilizzate per rappresentare istruzioni ad un livello di dettaglio
di singolo operatore. Il diagramma in seguito presenta i principali
raggruppamenti delle classi facenti parte del modulo di rappresentazione. Una
discussione di ciascuna di queste risulterebbe troppo estesa per essere
riportata all’interno di questa tesi e viene rimandata alla documentazione
fornita in accompagnamento alla libreria.\\

AGGIUNGI QUALI COMPOUND FORM VENGONO RAPPRESENTATE NEL DETTAGLIO E QUALI
VENGONO RAPPRESENTATE SEMPLICEMENTE COME APPLICAZIONI DI MACRO O FUNZIONE.\\

Gli operatori speciali indicati dallo standard ANSI Common Lisp, sezione
3.1.2.1.2 listato 2, più tutti gli operatori interessanti dal punto di vista
dell’analisi non presentati all’interno di quella lista. questi operatori
aggiuntivi sono quelli legati al CLOS, al meccanismo delle dichiarazioni e al
costrutto loop, in quanto particolarmente utilizzati e potenzialmente molto
significativi dal punto di vista dell’analisi. In presenza di qualsiasi altro
operatore, la rappresentazione si limita a riportare, l’applicazione di
questo, distinguendo se si tratta dell’applicazione di una funzione o di una
macro. Questa modalità di analisi consente di rappresentare qualsiasi
possibile compound form con il maggiore grado di precisione possibile a
seconda dello specifico caso in analisi.
